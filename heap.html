#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

// Function to construct a heap using the bottom-up algorithm
void HeapBottomUp(vector<int>& H) {
    int n = H.size() - 1; // Assuming H[1...n] (1-based index)
    for (int i = n / 2; i >= 1; --i) {
        int k = i;
        int v = H[k];
        bool heap = false;

        while (!heap && 2 * k <= n) {
            int j = 2 * k;
            if (j < n && H[j] < H[j + 1]) {
                j = j + 1;
            }
            if (v >= H[j]) {
                heap = true;
            } else {
                H[k] = H[j];
                k = j;
            }
        }
        H[k] = v;
    }
}

// Function to delete the maximum key (root) from the heap
void DeleteMax(vector<int>& H) {
    int n = H.size() - 1; // Assuming H[1...n] (1-based index)
    if (n < 1) return; // Heap is empty

    // Step 01: Exchange the root's key with the last key
    swap(H[1], H[n]);

    // Step 02: Decrease the heap's size by 1
    H.pop_back();
    n--;

    // Step 03: Heapify the smaller tree
    int k = 1;
    int v = H[k];
    bool heap = false;

    while (!heap && 2 * k <= n) {
        int j = 2 * k;
        if (j < n && H[j] < H[j + 1]) {
            j = j + 1;
        }
        if (v >= H[j]) {
            heap = true;
        } else {
            H[k] = H[j];
            k = j;
        }
    }
    if (k <= n) {
        H[k] = v;
    }
}

int main() {
    // Example usage
    vector<int> H = {0, 4, 10, 3, 5, 1}; // Using 1-based indexing, H[0] is ignored

    cout << "Original array: ";
    for (int i = 1; i < H.size(); ++i) {
        cout << H[i] << " ";
    }
    cout << endl;

    HeapBottomUp(H);

    cout << "Heap after HeapBottomUp: ";
    for (int i = 1; i < H.size(); ++i) {
        cout << H[i] << " ";
    }
    cout << endl;

    DeleteMax(H);

    cout << "Heap after DeleteMax: ";
    for (int i = 1; i < H.size(); ++i) {
        cout << H[i] << " ";
    }
    cout << endl;

    return 0;
}
